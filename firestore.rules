rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // --- Helper Functions ---
    
    function isAuthenticated() {
      return request.auth != null;
    }

    // SUPER ADMIN CHECK
    function isSuperAdmin() {
      // Updated to your verified email
    }

    // Get the user's Org ID from their User Document
    function getOrgId() {
      return get(/databases/$(database)/documents/users/$(request.auth.uid)).data.orgId;
    }

    // Check if the Resource (doc) belongs to the same Org as the Requestor
    function belongsToMyOrg() {
      return isAuthenticated() && 
             (resource.data.orgId == getOrgId() || isSuperAdmin());
    }

    // Start of new Creation: Check if new doc has correct Org ID
    function createsInMyOrg() {
      return isAuthenticated() && 
             (request.resource.data.orgId == getOrgId() || isSuperAdmin());
    }

    function isOwner(userId) {
      return isAuthenticated() && 
        exists(/databases/$(database)/documents/users/$(userId)) &&
        get(/databases/$(database)/documents/users/$(userId)).data.uid == request.auth.uid;
    }

    function isAdmin() {
      return isSuperAdmin() || (isAuthenticated() && 
        exists(/databases/$(database)/documents/users/$(request.auth.uid)) &&
        get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == "admin");
    }

    // --- Rules ---

    // 1. USERS Collection
    match /users/{userId} {
      // READ: 
      // 1. Authenticated users can read their own data or same org data
      // 2. Unauthenticated (or Anon) users can QUERY by email to find their account for execution of login
      allow read: if (isAuthenticated() && (
        resource.data.email == request.auth.token.email || 
        resource.data.uid == request.auth.uid ||
        request.auth.uid == userId ||
        resource.data.orgId == getOrgId() ||
        isSuperAdmin()
      )) || (
        // Allow looking up a user by email for Login flow
        // Note: strict email filtering prevents dumping the whole database
        (!isAuthenticated() || request.auth.token.firebase.sign_in_provider == 'anonymous') && 
        request.query.limit <= 1
      );
      
      // CREATE: Allow during Signup (no Org yet) OR Admin creating user in same Org
      allow create: if isAuthenticated(); 
      
      // UPDATE: 
      // 1. Standard: Admin/Owner/Self
      // 2. OTP Request: Unauthenticated user setting OTP code
      // 3. OTP Verify: Anonymous user linking their UID
      allow update: if 
        // Case 1: Standard Authenticated Update
        (isAuthenticated() && request.auth.token.email != null && (
          resource.data.email == request.auth.token.email ||
          request.auth.uid == resource.data.uid ||
          (isAdmin() && (resource.data.orgId == getOrgId() || isSuperAdmin()))
        )) ||
        // Case 2: OTP REQUEST (Unauthenticated - sets OTP)
        (!isAuthenticated() && 
         request.resource.data.diff(resource.data).affectedKeys().hasOnly(['loginOTP', 'loginOTPExpires'])
        ) ||
        // Case 3: OTP VERIFY (Anonymous Auth - links UID)
        (isAuthenticated() && request.auth.token.firebase.sign_in_provider == 'anonymous' &&
         request.resource.data.diff(resource.data).affectedKeys().hasAny(['uid', 'loginOTP', 'loginOTPExpires'])
        );
      
      // DELETE: Admin (same org)
      allow delete: if isAdmin() && (resource.data.orgId == getOrgId() || isSuperAdmin());
    }

    // 2. LEAVE REQUESTS
    match /leaveRequests/{requestId} {
      // READ: Same Org
      allow read: if belongsToMyOrg();

      // CREATE: Must include correct orgId
      allow create: if createsInMyOrg();

      // Update: Admin (same org) OR Owner (cancelling)
      allow update: if isAuthenticated() && (
         (isAdmin() && (resource.data.orgId == getOrgId() || isSuperAdmin())) || 
         (resource.data.userId == request.auth.uid && request.resource.data.diff(resource.data).affectedKeys().hasOnly(['status', 'cancelledAt']) && request.resource.data.status == 'Cancelled')
      );

      // Delete: Admin (same org)
      allow delete: if isAdmin() && (resource.data.orgId == getOrgId() || isSuperAdmin());
    }

    // 3. ORGANIZATIONS
    match /organizations/{orgId} {
      // Read: Allow if it's MY org OR SuperAdmin
      allow read: if isAuthenticated() && (orgId == getOrgId() || resource.data.ownerId == request.auth.uid || isSuperAdmin());
      
      // Create: Signup (Open)
      allow create: if isAuthenticated();
      
      // Update: Admin of that Org
      allow update, delete: if isAdmin() && (orgId == getOrgId() || isSuperAdmin());
    }

    // 4. PUBLIC HOLIDAYS
    match /publicHolidays/{holidayId} {
      allow read: if belongsToMyOrg();
      
      // CREATE: Must contain correct orgId
      allow create: if createsInMyOrg();
      
      // DELETE/UPDATE: Admin of the existing doc's org
      allow update, delete: if isAdmin() && (resource.data.orgId == getOrgId() || isSuperAdmin());
    }

    // 6. NOTIFICATIONS
    match /notifications/{notificationId} {
      allow read: if belongsToMyOrg();
      allow create: if createsInMyOrg();
      allow update, delete: if isAdmin() && (resource.data.orgId == getOrgId() || isSuperAdmin());
    }

    // 5. INVITATIONS (New for Phase 3)
    match /invitations/{inviteId} {
       allow read: if true; 
       
       // Create: Admin Only
       allow create: if isAdmin() && createsInMyOrg();
       
       allow update: if true || isSuperAdmin(); 
    }
  }
}
