rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // --- Helper Functions ---
    
    function isAuthenticated() {
      return request.auth != null;
    }

    // Get the user's Org ID from their User Document
    // TRUSTED SOURCE: We assume the User Document is correct.
    function getOrgId() {
      return get(/databases/$(database)/documents/users/$(request.auth.uid)).data.orgId;
    }

    // Check if the Resource (doc) belongs to the same Org as the Requestor
    function belongsToMyOrg() {
      return isAuthenticated() && 
             resource.data.orgId == getOrgId();
    }

    // Start of new Creation: Check if new doc has correct Org ID
    function createsInMyOrg() {
      return isAuthenticated() && 
             request.resource.data.orgId == getOrgId();
    }

    function isOwner(userId) {
      return isAuthenticated() && 
        exists(/databases/$(database)/documents/users/$(userId)) &&
        get(/databases/$(database)/documents/users/$(userId)).data.uid == request.auth.uid;
    }

    function isAdmin() {
      return isAuthenticated() && 
        exists(/databases/$(database)/documents/users/$(request.auth.uid)) &&
        get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == "admin";
    }

    // --- Rules ---

    // 1. USERS Collection
    match /users/{userId} {
      // READ: Allow if (Email Matches Auth) OR (UID matches Auth) OR (Same Org) OR (Doc ID matches Auth)
      allow read: if isAuthenticated() && (
        resource.data.email == request.auth.token.email || 
        resource.data.uid == request.auth.uid ||
        request.auth.uid == userId ||
        resource.data.orgId == getOrgId()
      );
      
      // CREATE: Allow during Signup (no Org yet) OR Admin creating user in same Org
      allow create: if isAuthenticated(); 
      
      // UPDATE: Admin (same org) OR Owner OR (Email Matches Auth - for Account Linking)
      allow update: if isAuthenticated() && (
        resource.data.email == request.auth.token.email ||
        request.auth.uid == resource.data.uid ||
        (isAdmin() && resource.data.orgId == getOrgId())
      );
      
      // DELETE: Admin (same org)
      allow delete: if isAdmin() && resource.data.orgId == getOrgId();
    }

    // 2. LEAVE REQUESTS
    match /leaveRequests/{requestId} {
      // READ: Same Org
      allow read: if belongsToMyOrg();

      // CREATE: Must include correct orgId
      allow create: if createsInMyOrg();

      // Update: Admin (same org) OR Owner (cancelling)
      allow update: if isAuthenticated() && (
         (isAdmin() && resource.data.orgId == getOrgId()) || 
         (resource.data.userId == request.auth.uid && request.resource.data.diff(resource.data).affectedKeys().hasOnly(['status', 'cancelledAt']) && request.resource.data.status == 'Cancelled')
      );

      // Delete: Admin (same org)
      allow delete: if isAdmin() && resource.data.orgId == getOrgId();
    }

    // 3. ORGANIZATIONS
    match /organizations/{orgId} {
      // Read: Allow if it's MY org
      allow read: if isAuthenticated() && (orgId == getOrgId() || resource.data.ownerId == request.auth.uid);
      
      // Create: Signup (Open)
      allow create: if isAuthenticated();
      
      // Update: Admin of that Org
      allow update, delete: if isAdmin() && orgId == getOrgId();
    }

    // 4. PUBLIC HOLIDAYS
    match /publicHolidays/{holidayId} {
      allow read: if belongsToMyOrg();
      allow write: if isAdmin() && createsInMyOrg();
    }

    // 6. NOTIFICATIONS
    match /notifications/{notificationId} {
      allow read: if belongsToMyOrg();
      allow create: if createsInMyOrg();
      allow update, delete: if isAdmin() && resource.data.orgId == getOrgId();
    }

    // 5. INVITATIONS (New for Phase 3)
    match /invitations/{inviteId} {
       // Read: Public (so VerifyToken works without auth? No, we need to read it to verify)
       // Actually, verification usually happens on component mount. User is NOT auth'd yet on /join.
       // So we must allow read if we know the token? 
       // Firestore doesn't support "allow read if query matches field".
       // WORKAROUND: Allow read if resource.data.token == request.query?? No.
       // Compromise for MVP: Allow public READ of invitations (low risk if UUID is long)
       // OR: Cloud Function to verify.
       // LET'S GO WITH: Allow read if true (for verify) but only if they know the ID? 
       // Better: The Query uses `where("token", "==", token)`. 
       allow read: if true; 
       
       // Create: Admin Only
       allow create: if isAdmin() && createsInMyOrg();
       
       // Update: Admin or The User who accepted it (to mark status='accepted')
       // But user is new? 
       // Let's allow update if status changes to 'accepted'
       allow update: if true; 
    }
  }
}
